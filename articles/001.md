# 告别 Pandas 性能焦虑：基于 Rust 的高性能量化因子库 py-alpha-lib 推荐

在量化投资研究中，**因子计算（Factor Research）** 是最耗时也最核心的环节之一。

大多数宽客（Quant）习惯使用 Pandas 来编写因子逻辑，但当你面对日频、分钟频甚至高频数据时，Pandas 的滚动窗口（Rolling Window）计算速度往往会成为瓶颈。虽然 DolphinDB 很快，但它有学习成本且部署相对重头。

最近在 GitHub 上发现了一个非常惊艳的开源库：**[py-alpha-lib](https://github.com/msd-rs/py-alpha-lib)**。它用 **Rust** 重新实现了底层的滚动窗口算法，并通过 Python 绑定供我们调用。实测性能比 Pandas 快了几个数量级.

---

### 一、 核心亮点：为什么选它？

#### 1. 极致的性能（Rust 驱动）

`py-alpha-lib` 的底层逻辑全部由 Rust 编写。Rust 天生具备极致的内存安全和并行能力。根据 README 披露的 Benchmark，在 4000 只股票、261 个交易日（共约 104 万个数据点）的测试中：

- **Alpha #001：** Pandas 耗时 14231ms，而 `alpha-lib` 仅需 **7ms**（提速 2000+ 倍）。
- **Alpha #004：** Pandas 耗时 55107ms，而 `alpha-lib` 仅需 **6ms**（提速 9000+ 倍）。

这种性能提升意味着，原本需要跑一个小时的因子回测，现在几秒钟就能出结果。

#### 2. 丰富的量化算法库

它实现了一些类似 AmiBroker (AFL) 或 DolphinDB 中的经典金融计算函数, 并会持续扩充：

- **趋势类：** `MA`, `EMA`, `SMA`, `DMA`
- **极值类：** `HHV` (最高值), `LLV` (最低值), `HHVBARS`
- **逻辑类：** `CROSS` (金叉/死叉), `BARSLAST` (自上次条件成立以来的周期数)
- **截面/分组：** 支持 `RANK` (截面排序) 和 `TS_RANK` (时序排序)

#### 3. 原生支持多股并行（Context 机制）

在处理多只股票的数据时，使用 Pandas 往往需要 `pivot` 或 `groupby`，这中数据的准备是比较耗时和消耗内存的, 然后在计算时又无法充分利用多核 CPU。

`py-alpha-lib` 使用一个长数组, 这是多只股票数据最高效的数据结构。然后通过 `set_ctx` ：

- 你可以设置 `groups`，库会自动将大数组切分成多个并行任务。
- 每个股票（Group）独立计算，互不干扰，完美利用多核 CPU。

#### 4. 因子表达式编译器

这是我觉得最酷的功能。它自带一个 `alpha.lang` 模块，可以将 WorldQuant 101 等因子表达式直接编译成 Python 代码。

```bash
python -m alpha.lang alpha101.txt

```

这对于批量复现论文因子简直是神器。

例如, 对于因子 #001：`(rank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2.), 5)) -0.5)`，编译后会生成如下 Python 代码：

```python
import numpy as np


# (rank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2.), 5)) -0.5)
def alpha_001(ctx):
  _RETURNS = ctx("RETURNS")
  return (
    ctx.RANK(
      ctx.TS_ARGMAX(
        ctx.SIGNEDPOWER(
          np.where(_RETURNS < 0, ctx.STDDEV(_RETURNS, 20), ctx("CLOSE")), 2.0
        ),
        5,
      )
    )
    - 0.5
  )

```

生成的代码并不依赖除了 `numpy` 以外的第三方库，只需要通过 `ctx` 传入数据和函数，就能直接调用。

---

### 二、 快速上手

安装非常简单：

```bash
pip install py-alpha-lib

```

写一个简单的移动平均（MA）计算：

```python
import alpha as al
import numpy as np

# 准备数据
data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], dtype=np.float64)

# 计算 3 周期均值
result = al.MA(data, 3)
print(result)
# 输出: [1.  1.5 2.  3.  4.  5.  6.  7.  8.  9. ]

# 处理 NaN 值：可以设置 Context 标志
# 计算时会自动跳过 NaN 干扰
data_with_nan = [1, 2, None, 4, 5, 6, 7, 8, 9, 10]
result = al.MA(data_with_nan, 3)
print(result)
# 输出: [1. 1.5 nan   2.333        3.667 5. 6. 7. 8. 9.]
#               (4+2+1)/3 = 2.333
```

---

### 三、 实战：复现 WorldQuant 101 Alpha

项目库中已经内置了 WorldQuant 101 因子的完整实现示例。如果你正在做因子挖掘，可以直接参考 `examples/wq101` 目录。

它不仅提供了高效的实现，还附带了与 Pandas 版本的正确性比对，确保计算结果既快又准。其中 DolphinDB 相关的数据从其[官方仓库获取](https://github.com/dolphindb/DolphinDBModules/blob/master/wq101alpha/README.md)。

以下是一些实测结果：
| 因子编号 | Pandas 耗时 (ms) | PyAlphaLib 耗时 (ms) | PyAlphaLib 提速倍数 | DolphinDB 提速倍数 |
|----------|------------------|------------------------|-----------|-----------|
| 加载数据 | 11396 | 718 | 15 | | | |
| #001 | 14231 | 7 | 2033 | 800 |
| #002 | 465 | 14 | 33 | 9 |
| #003 | 430 | 8 | 53 | 14 |
| #004 | 55107 | 6 | 9184 |
| #005 | 105 | 9 | 11 | 5 |
| #006 | 351 | 2 | 175 | 84 |
| #007 | 43816 | 17 | 2577 | 486 |
| #008 | 222 | 9 | 24 | 14 |
| #009 | 97 | 9 | 10 | 14 |
| #010 | 145 | 11 | 13 | 6 |
| #011 | 158 | 10 | 15 | 6 |
| #012 | 4 | 4 | 1 | 0.7 |
| #013 | 446 | 9 | 49 | 8 |
| #014 | 398 | 8 | 49 | 18 |

你可以在一个[云端的机器上复现这些结果](https://cnb.cool/elsejj/bench-of-alpha)，感受一下 `py-alpha-lib` 带来的性能飞跃。请注意, 由于机器的配置不同, 实际的提速倍数可能会有所差异。

---

### 四、 总结

如果你目前正面临以下困扰：

1. **Pandas 滚动计算太慢**，回测一次要等半天。
2. **不想为了性能去学 DolphinDB** 或其他复杂的数据库语言。
3. **需要处理海量历史数据**，希望利用多核 CPU 优势。

那么 `py-alpha-lib` 绝对是你工具箱里的新宠。它保持了 Python 的简洁，同时注入了 Rust 的灵魂。

**项目地址：** [https://github.com/msd-rs/py-alpha-lib](https://github.com/msd-rs/py-alpha-lib)

如果你觉得这个项目有用，记得去 GitHub 点个 **Star** 支持一下开发者！

---

_#量化交易 #Python #Rust #数据分析 #因子研究 #量化投资_
